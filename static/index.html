<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Storyengine</title>
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,500&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    html, body { height: 100%; }
    :root {
      color-scheme: dark;
      /* Fallen London / Cultist Simulator-inspired palette */
      --bg-0: #0b0f14;         /* abyssal blue-black */
      --bg-1: #121821;         /* deep ink */
      --panel: #161c27;        /* shadowed panel */
      --panel-2: #1c2330;      /* elevated panel */
      --bone: #e9e6d8;         /* parchment text */
      --muted: #b7b3a3;        /* muted parchment */
      --accent: #7a2f4b;       /* wine/rosewood */
      --accent-2: #2b6f6f;     /* occult teal */
      --border: #2a3140;       /* iron border */
      --glow: #a86c8a;         /* faint wine glow */
      --focus: #b89f5b;        /* antique gold */
    }

    body {
      margin: 0; padding: 0;
      color: var(--bone);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(122,47,75,0.08), transparent 60%),
        radial-gradient(1000px 500px at 80% 20%, rgba(43,111,111,0.08), transparent 60%),
        linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 100%);
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }

    .container { max-width: 820px; margin: 0 auto; padding: 20px; height: calc(100dvh - 40px); display: flex; flex-direction: column; }

    header { display: flex; align-items: baseline; gap: 10px; padding: 16px 0 10px; border-bottom: 1px solid var(--border); }
    h1 { font-family: "EB Garamond", Georgia, serif; font-weight: 700; font-size: 22px; margin: 0; letter-spacing: 0.5px; }
    .sigil { font-variant: small-caps; letter-spacing: 2px; color: var(--muted); }
    .small { opacity: 0.8; font-size: 12px; color: var(--muted); }

    .panel {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0)),
        radial-gradient(600px 200px at 50% -10%, rgba(168,108,138,0.08), transparent 70%),
        var(--panel);
      box-shadow: 0 0 0 1px rgba(184,159,91,0.04) inset, 0 10px 30px rgba(0,0,0,0.35);
    }

    .chat {
      /* Make chat fill available space and scroll */
      flex: 1;
      min-height: 0; /* allow flex child to shrink */
      display: flex;
      flex-direction: column;
      justify-content: flex-end; /* anchor short content to bottom */
      overflow-y: auto;
      scroll-behavior: smooth;
    }

    .msg { margin: 0 0 12px 0; padding: 10px 12px; border-radius: 8px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; border: 1px solid var(--border); }
    .u, .user { background: linear-gradient(180deg, rgba(122,47,75,0.18), rgba(122,47,75,0.12)); color: #f3eade; box-shadow: 0 0 0 1px rgba(122,47,75,0.3) inset; }
    .a, .assistant { background: linear-gradient(180deg, rgba(43,111,111,0.18), rgba(43,111,111,0.12)); color: #e8f4f1; box-shadow: 0 0 0 1px rgba(43,111,111,0.28) inset; }

    form { display: flex; gap: 10px; margin-top: 14px; }
    input[name=prompt] {
      flex: 1; padding: 12px 14px; border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--bone);
      outline: none;
      transition: border-color 120ms ease, box-shadow 120ms ease;
    }
    input[name=prompt]::placeholder { color: color-mix(in srgb, var(--muted) 80%, var(--bone)); opacity: 0.8; }
    input[name=prompt]:focus { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(184,159,91,0.18); }

    button {
      padding: 12px 16px; border: 1px solid var(--border); border-radius: 10px;
      background: linear-gradient(180deg, rgba(184,159,91,0.18), rgba(184,159,91,0.08));
      color: var(--bone);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 80ms ease, box-shadow 160ms ease, border-color 160ms ease;
    }
    button:hover { border-color: var(--focus); box-shadow: 0 0 12px rgba(184,159,91,0.18), 0 0 0 1px rgba(184,159,91,0.1) inset; }
    button:active { transform: translateY(1px); }
    button[aria-busy=true] { opacity: 0.7; cursor: progress; }

    /* Loading indicator */
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner {
      width: 14px; height: 14px; border: 2px solid var(--border);
      border-top-color: var(--focus); border-radius: 50%;
      display: inline-block; animation: spin 0.8s linear infinite;
      vertical-align: -2px; margin-right: 8px;
    }

    a { color: var(--focus); }

    /* Markdown content styling inside messages */
    .msg p { margin: 0 0 8px 0; }
    .msg pre { background: var(--panel-2); padding: 8px; border-radius: 6px; overflow: auto; }
    .msg code { background: var(--panel-2); padding: 2px 4px; border-radius: 4px; }
    .msg a { text-decoration: underline; }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/marked@12.0.2/marked.min.js"></script>
  <script src="https://unpkg.com/dompurify@3.0.6/dist/purify.min.js"></script>
</head>
<body>
  <div id="app" class="container">
    <header>
      <h1>Storyengine <span class="sigil" v-if="title && currentScreen === 'game'">â€” {{ title }}</span></h1>
      <span class="small">AI powered story game made with ðŸ¤– by <a href="https://github.com/fazo96" target="_blank"
          rel="noreferrer">fazo96</a></span>
    </header>

    <div style="display:flex; gap:10px; align-items:center; padding:10px 0 6px;">
      <span v-if="currentScreen === 'game'" class="small">Save: {{ title || 'New Game' }}<span v-if="saveId"> (#{{ saveId.slice(0,8) }})</span></span>
      <button @click="openWorlds" :disabled="isLoading">New Game</button>
      <button v-if="currentScreen === 'game'" @click="openLoad" :disabled="isLoading">Load Game</button>
      <button v-if="currentScreen === 'game'" @click="toggleBgm" :disabled="isLoading">{{ isBgmPlaying ? 'Pause Music' : 'Play Music' }}</button>
    </div>

    <div v-if="currentScreen === 'game'" id="messages" class="chat panel" aria-live="polite" :aria-busy="isLoading ? 'true' : 'false'">
      <div v-for="(m, i) in messages" :key="i" class="msg" :class="m.role">
        <template v-if="m.role === 'assistant' && (!m.content || m.content.length === 0) && isLoading">
          <span class="spinner" aria-hidden="true"></span>{{ loadingText }}
        </template>
        <template v-else>
          <div v-html="renderMarkdown(m.content)"></div>
        </template>
      </div>
    </div>

    <form v-if="currentScreen === 'game'" @submit.prevent="onSubmit">
      <input name="prompt" type="text" placeholder="Ask / Act / Reflect" autocomplete="off" required v-model="prompt" :disabled="isLoading">
      <button type="submit" :aria-busy="isLoading ? 'true' : 'false'" :disabled="isLoading">Synthetise</button>
    </form>

    <div v-if="currentScreen === 'load'" class="panel" style="margin-top:12px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <strong>Load Game</strong>
        <button @click="closeLoad">Close</button>
      </div>
      <div v-if="saves.length === 0" class="small">No saves yet.</div>
      <ul style="list-style:none; padding:0; margin:0;">
        <li v-for="s in saves" :key="s.id" style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px 10px; margin-bottom:8px; gap:8px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">{{ s.title || 'Untitled' }}</div>
            <div class="small">#{{ s.id.slice(0,8) }} Â· {{ new Date(s.updatedAt).toLocaleString() }}</div>
          </div>
          <div style="display:flex; gap:8px;">
            <button @click="loadExisting(s.id)">Load</button>
            <button @click="confirmDelete(s.id)" style="background: linear-gradient(180deg, rgba(122,47,75,0.22), rgba(122,47,75,0.10));">Delete</button>
          </div>
        </li>
      </ul>
    </div>

    <div v-if="currentScreen === 'worlds'" class="panel" style="margin-top:12px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <strong>Choose World</strong>
        <button @click="closeWorlds">Close</button>
      </div>
      <div v-if="worlds.length === 0" class="small">No worlds available.</div>
      <ul style="list-style:none; padding:0; margin:0;">
        <li v-for="w in worlds" :key="w.id" style="display:flex; gap:10px; border:1px solid var(--border); border-radius:8px; padding:10px; margin-bottom:8px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">{{ w.name }}</div>
            <div class="small" style="opacity:0.9; max-height:4.8em; overflow:hidden;">{{ w.description }}</div>
          </div>
          <div style="display:flex; align-items:center;">
            <button @click="startWorld(w.id)">Start</button>
          </div>
        </li>
      </ul>
    </div>
  </div>
  <script type="module">
    const { createApp, ref, watch, onBeforeUnmount, nextTick } = Vue;

    createApp({
      setup() {
        const messages = ref([]);
        const prompt = ref('');
        const isLoading = ref(false);
        const saveId = ref('');
        const worldId = ref('');
        const title = ref('New Game');
        // One place to control which screen is visible: 'home' | 'worlds' | 'load' | 'game'
        const currentScreen = ref('load');
        const worlds = ref([]);
        const saves = ref([]);
        // Background music element reference
        const bgmEl = ref(document.getElementById('bgm'));
        const isBgmPlaying = ref(false);

        // Themed loading phrases that cycle while waiting for a response
        const loadingPhrases = [
          'Consulting the Stationmasterâ€¦',
          'Listening to the rails whisperâ€¦',
          'Bartering with shadowsâ€¦',
          'Counting the teeth of old gearsâ€¦',
          'Stoking the occult engineâ€¦',
          'Peering beyond the veilâ€¦',
          'Summoning timetables from forgotten yearsâ€¦',
          'Feeding coal to the dreaming boilerâ€¦'
        ];
        const loadingText = ref(loadingPhrases[0]);
        let loadingTimer = null;
        let phraseIndex = 0;

        async function loadHistory(idOverride = null) {
          try {
            const id = typeof idOverride === 'string' ? idOverride : (saveId.value || '');
            const url = id ? `/api/history?saveId=${encodeURIComponent(id)}` : '/api/history';
            const res = await fetch(url);
            const data = await res.json().catch(() => ({}));
            const msgs = Array.isArray(data.messages) ? data.messages : [];
            const sid = typeof data.saveId === 'string' ? data.saveId : '';
            const t = typeof data.title === 'string' ? data.title : '';
            // Expect entries like { role: 'a'|'u', content: string }
            messages.value = msgs
              .filter(m => m && typeof m.content === 'string' && typeof m.role === 'string')
              .map(m => ({ role: m.role, content: m.content }));
            if (sid) {
              saveId.value = sid;
            }
            title.value = t || title.value;
            focusInput();
          } catch (e) {
            messages.value = [{ role: 'error', content: `Failed to load history: ${e instanceof Error ? e.message : String(e)}` }];
          }
        }

        async function onSubmit() {
          const value = prompt.value.trim();
          if (!value || isLoading.value) return;
          messages.value.push({ role: 'user', content: value });
          // Prepare an assistant placeholder message to stream into
          const assistantIndex = messages.value.push({ role: 'assistant', content: '' }) - 1;
          // Clear input immediately on send
          prompt.value = '';
          isLoading.value = true;
          try {
            const res = await fetch('/api/chat', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              // Send the full chat history so the backend can provide context
              body: JSON.stringify({ saveId: saveId.value || undefined, worldId: worldId.value || undefined, messages: messages.value })
            });

            if (!res.body) {
              throw new Error('No response body');
            }

            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split(/\r?\n/);
              buffer = lines.pop() || '';
              for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;
                let obj = null;
                try { obj = JSON.parse(trimmed); } catch { obj = null; }
                if (!obj || typeof obj !== 'object') continue;
                const type = obj.type;
                if (type === 'delta') {
                  const chunk = typeof obj.content === 'string' ? obj.content : '';
                  if (chunk) {
                    messages.value[assistantIndex].content += chunk;
                  }
                } else if (type === 'final') {
                  const role = typeof obj.role === 'string' ? obj.role : 'assistant';
                  const finalContent = typeof obj.content === 'string' ? obj.content : '';
                  const err = typeof obj.error === 'string' ? obj.error : '';
                  messages.value[assistantIndex].role = role;
                  messages.value[assistantIndex].content = err ? `Error: ${err}\n\n${finalContent}` : finalContent;
                  const sid = typeof obj.saveId === 'string' ? obj.saveId : '';
                  const t = typeof obj.title === 'string' ? obj.title : '';
                  if (sid) saveId.value = sid;
                  if (t) title.value = t;
                }
              }
            }
          } catch (e) {
            messages.value.push({ role: 'error', content: `Request failed: ${e instanceof Error ? e.message : String(e)}` });
          } finally {
            isLoading.value = false;
          }
        }

        function focusInput() {
          // Focus input field if present, also scroll messages container to bottom
          setTimeout(() => {
            const messagesEl = document.getElementById('messages');
            if (messagesEl) {
              messagesEl.scrollTop = messagesEl.scrollHeight;
            }
            const input = document.querySelector('input, textarea');
            if (input) input.focus();
          }, 100);
        }

        function openWorlds() {
          currentScreen.value = 'worlds';
          fetch('/api/worlds')
            .then(r => r.json())
            .then(d => {
              const arr = Array.isArray(d.worlds) ? d.worlds : [];
              worlds.value = arr
                .filter(w => w && typeof w.id === 'string' && typeof w.name === 'string')
                .map(w => ({ id: w.id, name: String(w.name), description: String(w.description || ''), intro: String(w.intro || '') }));
            })
            .catch(() => { worlds.value = []; });
        }

        function closeWorlds() { currentScreen.value = 'game'; }

        async function startWorld(selectedWorldId) {
          if (!selectedWorldId || isLoading.value) return;
          isLoading.value = true;
          try {
            const res = await fetch(`/api/history?worldId=${encodeURIComponent(selectedWorldId)}`);
            const data = await res.json().catch(() => ({}));
            if (typeof data.error === 'string' && data.error) {
              throw new Error(data.error);
            }
            const msgs = Array.isArray(data.messages) ? data.messages : [];
            messages.value = msgs
              .filter(m => m && typeof m.content === 'string' && typeof m.role === 'string')
              .map(m => ({ role: m.role, content: m.content }));
            const sid = typeof data.saveId === 'string' ? data.saveId : '';
            const wid = typeof data.worldId === 'string' ? data.worldId : '';
            const t = typeof data.title === 'string' ? data.title : '';
            if (sid) {
              saveId.value = sid;
            } else {
              saveId.value = '';
            }
            if (wid) {
              worldId.value = wid;
            } else {
              worldId.value = '';
            }
            title.value = t || 'New Game';
            await playBgm();
          } catch (e) {
            alert(`Failed to start world: ${e instanceof Error ? e.message : String(e)}`);
          } finally {
            isLoading.value = false;
            currentScreen.value = 'game';
            focusInput();
          }
        }

        function openLoad() {
          currentScreen.value = 'load';
          fetch('/api/saves')
            .then(r => r.json())
            .then(d => {
              const arr = Array.isArray(d.saves) ? d.saves : [];
              saves.value = arr
                .filter(s => s && typeof s.id === 'string')
                .map(s => ({ id: s.id, title: typeof s.title === 'string' ? s.title : 'Untitled', updatedAt: Number(s.updatedAt) || 0 }));
            })
            .catch(() => { saves.value = []; });
        }

        function closeLoad() { currentScreen.value = 'game'; }

        async function loadExisting(id) {
          await loadHistory(id);
          currentScreen.value = 'game';
          await playBgm();
        }

        async function playBgm() {
          const el = bgmEl.value;
          if (!el) return;

          try {
            el.volume = 0.5;
            await el.play();
            isBgmPlaying.value = true;
          } catch (_) {
            isBgmPlaying.value = false;
          }
        }

        async function pauseBgm() {
          const el = bgmEl.value;
          if (!el) return;
          try {
            await el.pause();
          } finally {
            isBgmPlaying.value = false;
          }
        }

        function toggleBgm() {
          const el = bgmEl.value;
          console.log('toggleBgm', el);
          if (!el) return;
          if (el.paused) {
            playBgm();
          } else {
            pauseBgm();
          }
        }

        async function deleteSave(id) {
          try {
            const res = await fetch(`/api/saves/${encodeURIComponent(id)}`, { method: 'DELETE' });
            const data = await res.json().catch(() => ({}));
            const ok = !!data.ok;
            if (ok) {
              // If the deleted save is the current one, reset session
              if (saveId.value && saveId.value === id) {
                currentScreen.value = 'worlds';
                worldId.value = '';
                saveId.value = '';
                title.value = 'New Game';
              }
              // Refresh saves list in the loader
              openLoad();
            } else {
              alert('Failed to delete save. It may not exist.');
            }
          } catch (e) {
            alert(`Delete failed: ${e instanceof Error ? e.message : String(e)}`);
          }
        }

        function confirmDelete(id) {
          const sure = confirm('Delete this save? This cannot be undone.');
          if (sure) deleteSave(id);
        }

        // Cycle through loading phrases while isLoading is true
        watch(isLoading, (active) => {
          if (active) {
            phraseIndex = Math.floor(Math.random() * loadingPhrases.length);
            loadingText.value = loadingPhrases[phraseIndex];
            if (loadingTimer) clearInterval(loadingTimer);
            loadingTimer = setInterval(() => {
              phraseIndex = (phraseIndex + 1) % loadingPhrases.length;
              loadingText.value = loadingPhrases[phraseIndex];
            }, 3000);
          } else {
            if (loadingTimer) {
              clearInterval(loadingTimer);
              loadingTimer = null;
            }
          }
        });

        // Keep messages scrolled to bottom by default so older messages overflow upward
        watch(messages, async () => {
          await nextTick();
          const messagesEl = document.getElementById('messages');
          if (messagesEl) {
            messagesEl.scrollTop = messagesEl.scrollHeight;
          }
        });

        onBeforeUnmount(() => {
          if (loadingTimer) clearInterval(loadingTimer);
        });

        // Show saves list by default on start
        openLoad();

        function renderMarkdown(text) {
          try {
            const md = window.marked;
            // Render GitHub-flavored markdown with line-breaks
            md.setOptions({ breaks: true, gfm: true, mangle: false, headerIds: false });
            const rawHtml = md.parse(String(text ?? ''));
            return window.DOMPurify.sanitize(rawHtml);
          } catch (_) {
            return String(text ?? '');
          }
        }

        return {
          messages,
          prompt,
          isLoading,
          onSubmit,
          loadingText,
          saveId,
          title,
          saves,
          openWorlds,
          closeWorlds,
          startWorld,
          openLoad,
          closeLoad,
          loadExisting,
          deleteSave,
          confirmDelete,
          renderMarkdown,
          bgmEl,
          isBgmPlaying,
          toggleBgm,
          worlds,
          currentScreen
        };
      }
    }).mount('#app');
  </script>
  <!-- Background music; hidden, controlled via user actions (New/Load) -->
  <audio id="bgm" ref="bgmEl" src="/static/assets/Shadows%20in%20the%20Fog.mp3" preload="none" loop style="display:none"></audio>
</body>
</html>


