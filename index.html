<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Storyengine</title>
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,500&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      /* Fallen London / Cultist Simulator-inspired palette */
      --bg-0: #0b0f14;         /* abyssal blue-black */
      --bg-1: #121821;         /* deep ink */
      --panel: #161c27;        /* shadowed panel */
      --panel-2: #1c2330;      /* elevated panel */
      --bone: #e9e6d8;         /* parchment text */
      --muted: #b7b3a3;        /* muted parchment */
      --accent: #7a2f4b;       /* wine/rosewood */
      --accent-2: #2b6f6f;     /* occult teal */
      --border: #2a3140;       /* iron border */
      --glow: #a86c8a;         /* faint wine glow */
      --focus: #b89f5b;        /* antique gold */
    }

    body {
      margin: 0; padding: 0;
      color: var(--bone);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(122,47,75,0.08), transparent 60%),
        radial-gradient(1000px 500px at 80% 20%, rgba(43,111,111,0.08), transparent 60%),
        linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 100%);
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }

    .container { max-width: 820px; margin: 0 auto; padding: 20px; }

    header { display: flex; align-items: baseline; gap: 10px; padding: 16px 0 10px; border-bottom: 1px solid var(--border); }
    h1 { font-family: "EB Garamond", Georgia, serif; font-weight: 700; font-size: 22px; margin: 0; letter-spacing: 0.5px; }
    .sigil { font-variant: small-caps; letter-spacing: 2px; color: var(--muted); }
    .small { opacity: 0.8; font-size: 12px; color: var(--muted); }

    .chat {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      min-height: 280px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0)),
        radial-gradient(600px 200px at 50% -10%, rgba(168,108,138,0.08), transparent 70%),
        var(--panel);
      box-shadow: 0 0 0 1px rgba(184,159,91,0.04) inset, 0 10px 30px rgba(0,0,0,0.35);
    }

    .msg { margin: 0 0 12px 0; padding: 10px 12px; border-radius: 8px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; border: 1px solid var(--border); }
    .u { background: linear-gradient(180deg, rgba(122,47,75,0.18), rgba(122,47,75,0.12)); color: #f3eade; box-shadow: 0 0 0 1px rgba(122,47,75,0.3) inset; }
    .a { background: linear-gradient(180deg, rgba(43,111,111,0.18), rgba(43,111,111,0.12)); color: #e8f4f1; box-shadow: 0 0 0 1px rgba(43,111,111,0.28) inset; }

    form { display: flex; gap: 10px; margin-top: 14px; }
    input[name=prompt] {
      flex: 1; padding: 12px 14px; border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--bone);
      outline: none;
      transition: border-color 120ms ease, box-shadow 120ms ease;
    }
    input[name=prompt]::placeholder { color: color-mix(in srgb, var(--muted) 80%, var(--bone)); opacity: 0.8; }
    input[name=prompt]:focus { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(184,159,91,0.18); }

    button {
      padding: 12px 16px; border: 1px solid var(--border); border-radius: 10px;
      background: linear-gradient(180deg, rgba(184,159,91,0.18), rgba(184,159,91,0.08));
      color: var(--bone);
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 80ms ease, box-shadow 160ms ease, border-color 160ms ease;
    }
    button:hover { border-color: var(--focus); box-shadow: 0 0 12px rgba(184,159,91,0.18), 0 0 0 1px rgba(184,159,91,0.1) inset; }
    button:active { transform: translateY(1px); }
    button[aria-busy=true] { opacity: 0.7; cursor: progress; }

    /* Loading indicator */
    @keyframes spin { to { transform: rotate(360deg); } }
    .spinner {
      width: 14px; height: 14px; border: 2px solid var(--border);
      border-top-color: var(--focus); border-radius: 50%;
      display: inline-block; animation: spin 0.8s linear infinite;
      vertical-align: -2px; margin-right: 8px;
    }

    a { color: var(--focus); }

    /* Markdown content styling inside messages */
    .msg p { margin: 0 0 8px 0; }
    .msg pre { background: var(--panel-2); padding: 8px; border-radius: 6px; overflow: auto; }
    .msg code { background: var(--panel-2); padding: 2px 4px; border-radius: 4px; }
    .msg a { text-decoration: underline; }
  </style>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/marked@12.0.2/marked.min.js"></script>
  <script src="https://unpkg.com/dompurify@3.0.6/dist/purify.min.js"></script>
</head>
<body>
  <div id="app" class="container">
    <header>
      <h1>Storyengine <span class="sigil" v-if="title && !showLoad">â€” {{ title }}</span></h1>
      <span class="small">AI powered story game</span>
    </header>

    <div style="display:flex; gap:10px; align-items:center; padding:10px 0 6px;">
      <span v-if="!showLoad" class="small">Save: {{ title || 'New Game' }}<span v-if="saveId"> (#{{ saveId.slice(0,8) }})</span></span>
      <button @click="newGame" :disabled="isLoading">New Game</button>
      <button v-if="!showLoad" @click="openLoad" :disabled="isLoading">Load Game</button>
    </div>

    <div v-if="!showLoad" id="messages" class="chat" aria-live="polite" :aria-busy="isLoading ? 'true' : 'false'">
      <div v-for="(m, i) in messages" :key="i" class="msg" :class="m.role" v-html="renderMarkdown(m.content)"></div>
      <div v-if="isLoading" class="msg a"><span class="spinner" aria-hidden="true"></span>{{ loadingText }}</div>
    </div>

    <form v-if="!showLoad" @submit.prevent="onSubmit">
      <input name="prompt" type="text" placeholder="Ask / Act / Reflect" autocomplete="off" required v-model="prompt" :disabled="isLoading">
      <button type="submit" :aria-busy="isLoading ? 'true' : 'false'" :disabled="isLoading">Speak</button>
    </form>

    <div v-if="showLoad" class="chat" style="margin-top:12px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <strong>Load Game</strong>
        <button @click="closeLoad">Close</button>
      </div>
      <div v-if="saves.length === 0" class="small">No saves yet.</div>
      <ul style="list-style:none; padding:0; margin:0;">
        <li v-for="s in saves" :key="s.id" style="display:flex; justify-content:space-between; align-items:center; border:1px solid var(--border); border-radius:8px; padding:8px 10px; margin-bottom:8px; gap:8px;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">{{ s.title || 'Untitled' }}</div>
            <div class="small">#{{ s.id.slice(0,8) }} Â· {{ new Date(s.updatedAt).toLocaleString() }}</div>
          </div>
          <div style="display:flex; gap:8px;">
            <button @click="loadExisting(s.id)">Load</button>
            <button @click="confirmDelete(s.id)" style="background: linear-gradient(180deg, rgba(122,47,75,0.22), rgba(122,47,75,0.10));">Delete</button>
          </div>
        </li>
      </ul>
    </div>

    <p class="small">Made with ðŸ¤– by <a href="https://github.com/fazo96" target="_blank" rel="noreferrer">fazo96</a>.</p>
  </div>
  <script type="module">
    const { createApp, ref, watch, onBeforeUnmount } = Vue;

    createApp({
      setup() {
        const messages = ref([]);
        const prompt = ref('');
        const isLoading = ref(false);
        const saveId = ref('');
        const title = ref('New Game');
        const showLoad = ref(true);
        const saves = ref([]);

        // Themed loading phrases that cycle while waiting for a response
        const loadingPhrases = [
          'Consulting the Stationmasterâ€¦',
          'Listening to the rails whisperâ€¦',
          'Bartering with shadowsâ€¦',
          'Counting the teeth of old gearsâ€¦',
          'Stoking the occult engineâ€¦',
          'Peering beyond the veilâ€¦',
          'Summoning timetables from forgotten yearsâ€¦',
          'Feeding coal to the dreaming boilerâ€¦'
        ];
        const loadingText = ref(loadingPhrases[0]);
        let loadingTimer = null;
        let phraseIndex = 0;

        async function loadHistory(idOverride = null) {
          try {
            const id = typeof idOverride === 'string' ? idOverride : (saveId.value || '');
            const url = id ? `/api/history?saveId=${encodeURIComponent(id)}` : '/api/history';
            const res = await fetch(url);
            const data = await res.json().catch(() => ({}));
            const msgs = Array.isArray(data.messages) ? data.messages : [];
            const sid = typeof data.saveId === 'string' ? data.saveId : '';
            const t = typeof data.title === 'string' ? data.title : '';
            // Expect entries like { role: 'a'|'u', content: string }
            messages.value = msgs
              .filter(m => m && typeof m.content === 'string' && typeof m.role === 'string')
              .map(m => ({ role: m.role, content: m.content }));
            if (sid) {
              saveId.value = sid;
            }
            title.value = t || title.value;
            focusInput();
          } catch (e) {
            messages.value = [{ role: 'error', content: `Failed to load history: ${e instanceof Error ? e.message : String(e)}` }];
          }
        }

        async function onSubmit() {
          const value = prompt.value.trim();
          if (!value || isLoading.value) return;
          messages.value.push({ role: 'user', content: value });
          // Clear input immediately on send
          prompt.value = '';
          isLoading.value = true;
          try {
            const res = await fetch('/api/chat', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              // Send the full chat history so the backend can provide context
              body: JSON.stringify({ saveId: saveId.value || undefined, messages: messages.value })
            });
            const data = await res.json().catch(() => ({}));
            const role = typeof data.role === 'string' ? data.role : '';
            const dataContent = typeof data.content === 'string' ? data.content : '';
            const error = typeof data.error === 'string' ? data.error : '';
            const content = error ? `Error: ${error}` : dataContent;
            messages.value.push({ role: role, content });
            const sid = typeof data.saveId === 'string' ? data.saveId : '';
            const t = typeof data.title === 'string' ? data.title : '';
            if (sid) {
              saveId.value = sid;
            }
            if (t) title.value = t;
          } catch (e) {
            messages.value.push({ role: 'error', content: `Request failed: ${e instanceof Error ? e.message : String(e)}` });
          } finally {
            isLoading.value = false;
          }
        }

        function focusInput() {
          // Focus input field if present, also scroll to the bottom of the page
          setTimeout(() => {
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            const input = document.querySelector('input, textarea');
            if (input) input.focus();
          }, 100);
        }

        async function newGame() {
          if (isLoading.value) return;
          isLoading.value = true;
          showLoad.value = false;
          try {
            const res = await fetch('/api/history');
            const data = await res.json().catch(() => ({}));
            const msgs = Array.isArray(data.messages) ? data.messages : [];
            messages.value = msgs
              .filter(m => m && typeof m.content === 'string' && typeof m.role === 'string')
              .map(m => ({ role: m.role, content: m.content }));
            const sid = typeof data.saveId === 'string' ? data.saveId : '';
            const t = typeof data.title === 'string' ? data.title : '';
            if (sid) {
              saveId.value = sid;
            }
            title.value = t || 'New Game';
          } finally {
            isLoading.value = false;
            focusInput();
          }
        }

        function openLoad() {
          showLoad.value = true;
          fetch('/api/saves')
            .then(r => r.json())
            .then(d => {
              const arr = Array.isArray(d.saves) ? d.saves : [];
              saves.value = arr
                .filter(s => s && typeof s.id === 'string')
                .map(s => ({ id: s.id, title: typeof s.title === 'string' ? s.title : 'Untitled', updatedAt: Number(s.updatedAt) || 0 }));
            })
            .catch(() => { saves.value = []; });
        }

        function closeLoad() { showLoad.value = false; }

        async function loadExisting(id) {
          await loadHistory(id);
          showLoad.value = false;
        }

        async function deleteSave(id) {
          try {
            const res = await fetch(`/api/saves/${encodeURIComponent(id)}`, { method: 'DELETE' });
            const data = await res.json().catch(() => ({}));
            const ok = !!data.ok;
            if (ok) {
              // If the deleted save is the current one, reset session
              if (saveId.value && saveId.value === id) {
                await newGame();
                saveId.value = '';
                title.value = 'New Game';
              }
              // Refresh saves list in the loader
              openLoad();
            } else {
              alert('Failed to delete save. It may not exist.');
            }
          } catch (e) {
            alert(`Delete failed: ${e instanceof Error ? e.message : String(e)}`);
          }
        }

        function confirmDelete(id) {
          const sure = confirm('Delete this save? This cannot be undone.');
          if (sure) deleteSave(id);
        }

        // Cycle through loading phrases while isLoading is true
        watch(isLoading, (active) => {
          if (active) {
            phraseIndex = Math.floor(Math.random() * loadingPhrases.length);
            loadingText.value = loadingPhrases[phraseIndex];
            if (loadingTimer) clearInterval(loadingTimer);
            loadingTimer = setInterval(() => {
              phraseIndex = (phraseIndex + 1) % loadingPhrases.length;
              loadingText.value = loadingPhrases[phraseIndex];
            }, 3000);
          } else {
            if (loadingTimer) {
              clearInterval(loadingTimer);
              loadingTimer = null;
            }
          }
        });

        onBeforeUnmount(() => {
          if (loadingTimer) clearInterval(loadingTimer);
        });

        // Show saves list by default on start
        openLoad();

        function renderMarkdown(text) {
          try {
            const md = window.marked;
            // Render GitHub-flavored markdown with line-breaks
            md.setOptions({ breaks: true, gfm: true, mangle: false, headerIds: false });
            const rawHtml = md.parse(String(text ?? ''));
            return window.DOMPurify.sanitize(rawHtml);
          } catch (_) {
            return String(text ?? '');
          }
        }

        return {
          messages,
          prompt,
          isLoading,
          onSubmit,
          loadingText,
          saveId,
          title,
          showLoad,
          saves,
          newGame,
          openLoad,
          closeLoad,
          loadExisting,
          deleteSave,
          confirmDelete,
          renderMarkdown
        };
      }
    }).mount('#app');
  </script>
</body>
</html>


